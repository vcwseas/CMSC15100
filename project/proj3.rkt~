;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-advanced-reader.ss" "lang")((modname proj3) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ())))
;; CS 151 University of Chicago
;; Autumn 2013
;; Project 3 seed code
;; (c) John Reppy, Adam Shaw; Nov 2013

;; acknowledgements to Joe Ellis and Tristan Rasmussen for
;; helping develop prototype implementation

(require racket/match)
(require 2htdp/image)
(require 2htdp/universe)

;;;;;;;;;;;;;;;;;;;; GENERAL UTILITY CODE ;;;;;;;;;;;;;;;;;;;;

;; nat-fold : (nat X -> X) X nat -> X
;; computes f(n-1, f(n-2, ... f(0, init) ... ))
(define (nat-fold f n init)
  (local
    {(define (fold i acc) (if (< i n) (fold (add1 i) (f i acc)) acc))}
    (fold 0 init)))

(check-expect (nat-fold cons 4 '()) '(3 2 1 0))

;; list-flatten : (listof (listof X)) -> (listof X)
;; flatten a list of lists into a list
(define (list-flatten ll)
  (foldr append '() ll))

;;;;;;;;;;;;;;;;;;;; PLAYER, MOVE, AND GAME DATA DEFINITIONS ;;;;;;;;;;;;;;;;;;;;

;; a (pair X Y) is a (make-pair x y), where 
;; x is an X and y is a Y.
(define-struct pair (fst snd))

;; a size is either 1, 2, or 3,
;; representing small, medium, large in that order

;; a player is either 'blue or 'orange

;; a square is a natural number between 0 and 8 inclusive

;; a piece is a (make-piece s p) where
;; - s is a size, and
;; - p is a player
(define-struct piece (size player))

;; an intro is a (make-intro p s) where
;; - p is a piece, and
;; - s is a square
(define-struct intro (piece square))

;; a shft is a (make-shft src dst) where
;; - src and dst are both squares
(define-struct shft (src dst))

;; a move is either
;; - an intro, or
;; - a shft

;; an inventory is a (listof piece) ordered by increasing size

;; a board is a (listof (listof piece)) representing a rectangular
;; grid of squares.  The playing board is a 3x3 grid, while the
;; inventory boards are 3x2 grids. Each square is represented
;; by a list of pieces, where the pieces are ordered from outermost
;; (i.e., biggest) to innermost (smallest).  An square with no pieces
;; is represented by the empty list.  The order of the squares in
;; this list is row-major order; for example, the playing board
;; squares are ordered as follows:
;;
;;    0 1 2
;;    3 4 5
;;    6 7 8

;; a game is a (make-game next inv board) where
;; - next is a player, 
;; - inv is a pair (make-pair oinv binv), where
;;   - oinv ("orange inventory") is an inventory,
;;   - binv ("blue inventory") is an inventory, and
;; - board is a board (per definition above)
(define-struct game (next inv board))

;;;;;;;;;;;;;;;;;;;; PLAYER, MOVE, AND GAME CODE FOR PROJECT 2 ;;;;;;;;;;;;;;;;;;;;

;; the pieces (useful for testing)
;;
(define orange1 (make-piece 1 'orange))
(define orange2 (make-piece 2 'orange))
(define orange3 (make-piece 3 'orange))
(define blue1   (make-piece 1 'blue))
(define blue2   (make-piece 2 'blue))
(define blue3   (make-piece 3 'blue))

;; piece=? : piece piece -> bool
;; equality test on pieces
;;
(define (piece=? p q)
  (match* (p q)
    [((piece ps pp) (piece qs qp))
     (and (= ps qs) (symbol=? pp qp))]))

(check-expect (piece=? orange1 orange2) #f)
(check-expect (piece=? orange1 blue1) #f)
(check-expect (piece=? blue3 blue3) #t)

;; move->string : move -> string 
;; return a string representation of a move (convenience)
(define (move->string m)
 (local 
   {(define $ string-append)
    (define n number->string)}
 (match m
   [(shft s d) ($ "S/" (n s) "=>" (n d))]
   [(intro (piece s c) i) 
    ($ "I/" (if (symbol=? 'blue c) "B" "O") (n s) "=>" (n i))])))

;; other-player : player -> player
;; given a player, return the other player
(define (other-player player) 
  (match player
    ['orange 'blue]
    ['blue 'orange]))

;; select-by-player : player (pair X X) -> X
;; select the orange/blue item depending on the value of player
(define (select-by-player player items)
  (match* (player items)
    [('orange (pair item _)) item]
    [('blue   (pair _ item)) item]))

;; map-by-player : (X -> X) player (pair X X) -> (pair X X)
;; apply the pair of items to a new pair by applying the function f to the
;; items corresponding to player and leaving the other item unchanged.
(define (map-by-player f player items)
  (match* (player items)
    [('orange (pair orange blue)) (make-pair (f orange) blue)]
    [('blue   (pair orange blue)) (make-pair orange (f blue))]))

;; new-inv : player -> inventory
;; create a new inventory for player p
(define (new-inv p)
  (build-list 6 (λ (i) (make-piece (add1 (floor (/ i 2))) p))))

;; new-game : player -> game
;; create a new game where player p goes first
(define (new-game p)
  (make-game p 
             (make-pair (new-inv 'orange) (new-inv 'blue)) 
             (make-list 9 empty)))

;; pieces-at : board int -> (listof piece)
;; return the list of pieces at the given game-board square
(define (pieces-at b i) (list-ref b i))

;; update-at : board int (listof piece) -> board
;; functional update of board b: replace the value of square i by ps
(define (update-at b i ps)
  (local
    {(define (update j pss)
       (if (= j i)
           (cons ps (rest pss))
           (cons (first pss) (update (add1 j) (rest pss)))))}
    (update 0 b)))

;; b-3b1 : board (for tests)
(define b-3b1
  (list '() '() '() (list blue1) '() '() '() '() '()))

(check-expect (update-at (make-list 9 empty) 3 (list blue1))
              b-3b1)

;; square-available? : piece square board -> bool
;; tests if legal to place piece p at square i on board b
(define (square-available? p i b)
  (local {(define ps (pieces-at b i))}
    (or (empty? ps) 
        (> (piece-size p) (piece-size (first ps))))))

(check-expect (square-available? orange2 3 b-3b1) true)

;; lift-top-piece : board square -> board
;; remove first piece from square i on board b, returning new board  
;; PRE: given square occupied by at least one piece
(define (lift-top-piece b i) 
  (update-at b i (rest (pieces-at b i))))

(check-expect (lift-top-piece b-3b1 3)
              (make-list 9 empty))

;; a list of the winning board positions
(define winners
  '((0 1 2) (3 4 5) (6 7 8)  ;; three across
    (0 3 6) (1 4 7) (2 5 8)  ;; three down
    (0 4 8) (2 4 6)))        ;; diagonal

;; board-victory? : player board -> bool
;; test whether the given player is victorious in the given board state
(define (board-victory? player brd)
  (local
    {(define (has-sq i)
       (local {(define ps (pieces-at brd i))}
         (and (cons? ps) (symbol=? player (piece-player (first ps))))))}
    (ormap (lambda (sqs) (andmap has-sq sqs)) winners)))

(check-expect
 (board-victory? 'blue
                 (list '() '() '()
                       (list blue1) (list blue2) (list blue3)
                       '() '() '()))
 #t)

(check-expect
 (board-victory? 'blue
                 (list '() '() '()
                       (list blue1) (list orange1) (list blue3)
                       '() '() '()))
 #f)
                     
;; victory? : player game -> bool
;; test whether the given player is victorious in the given game state.
(define (victory? player g) 
  (board-victory? player (game-board g)))

;; apply-intro-lift : piece game -> game
;; remove the piece from the owning player's inventory  
;; PRE: the piece belongs to the current player
(define (apply-intro-lift p g)
  (local
    {(define (remove ps)
       (cond
         [(empty? ps) (error 'apply-intro.remove "piece not in inventory")]
         [(piece=? (first ps) p) (rest ps)]
         [else (cons (first ps) (remove (rest ps)))]))
     (define player (piece-player p))}
    (make-game
     (game-next g)
     (map-by-player remove player (game-inv g))
     (game-board g))))

;; apply-shft-lift : square game -> (pair piece game)
;; lift piece off given square, return pair of that piece and game without it
(define (apply-shft-lift src g)
  (local
    {(define brd (game-board g))
     (define ps (pieces-at brd src))}
    (make-pair
     (first ps)
     (make-game (game-next g) (game-inv g) (update-at brd src (rest ps))))))

;; apply-drop : piece square game -> game
;; place given piece on given square
;; PRE: square is available to that piece
(define (apply-drop p dst g)
  (make-game
   (game-next g)
   (game-inv g)
   (update-at (game-board g) dst (cons p (pieces-at (game-board g) dst)))))

;; switch-players : game -> game
;; toggle next player in game
(define (switch-players g)
  (match g [(game p i b)
    (make-game (other-player p) i b)]))

;;;;;;;;;;;;;;;;;;;; RENDERING CODE FOR PROJECT 2 ;;;;;;;;;;;;;;;;;;;;

;; the size of a square in pixels
;;
(define square-sz 100)
(define square-radius (/ square-sz 2))

;; the radii of the pieces
;;
(define piece-radii '(20 30 40))

;; the size of the board in squares
;;
(define board-num-rows 3)
(define board-num-cols 3)

;; the size of an inventory in squares
;;
(define inv-num-rows 3)
(define inv-num-cols 2)

;; the size of the board in pixels
;;
(define board-wid (* board-num-cols square-sz))
(define board-ht (* board-num-rows square-sz))

;; the size of an inventory in pixels
;;
(define inv-wid (* inv-num-cols square-sz))
(define inv-ht (* inv-num-rows square-sz))

;; padding between grids
;;
(define padding 5)

;; the size of the window in pixels
;;
(define win-wid (+ inv-wid padding board-wid padding inv-wid))
(define win-ht board-ht)

;; A tile-grid is a (make-tile-grid ulc n m fg-color bg-color) that represents an
;; n x m grid of square tiles, where
;;  - ulc is a posn (the universal coordinates of the upper-left corner of the grid)
;;  - n is a nat (the number of rows),
;;  - m is a nat (the number of squares per row),
;;  - fg-color is a string (the foreground color), and
;;  - bg-color is a string (the background color). 
;;
(define-struct tile-grid (ulc nrows ncols foreground background))

;; the grids for the orange player, the board, and the blue player
;; are laid out left to right.
;;
(define orange-inv-grid (make-tile-grid (make-posn 0 0) 3 2 "black" "Cornsilk"))
(define board-grid (make-tile-grid (make-posn inv-wid 0) 3 3 "black" "white"))
(define blue-inv-grid (make-tile-grid (make-posn (+ inv-wid board-wid) 0) 3 2 "black" "LightCyan"))

;; tile-grid-width : tile-grid -> nat
;; return the width of a tile-grid in pixels
;;
(define (tile-grid-width grid) (* square-sz (tile-grid-ncols grid)))

;; tile-grid-height : tile-grid -> nat
;; return the width of a tile-grid in pixels
;;
(define (tile-grid-height grid) (* square-sz (tile-grid-nrows grid)))

;; draw-grid-background : tile-grid color color -> image
;; render an image for the grid's background with the given colors for the
;; grid lines and square backgrounds.
;;
(define (draw-grid-background grid)
  (local
    {(define wid (tile-grid-width grid))
     (define ht (tile-grid-height grid))
     (define hline (rectangle (- wid 4) 4 'solid (tile-grid-foreground grid)))
     (define vline (rectangle 4 (- ht 4) 'solid (tile-grid-foreground grid)))
     (define (place-hline i img)
       (place-image/align hline 2 (+ square-sz (* i square-sz)) "left" "top" img))
     (define (place-vline i img)
       (place-image/align vline (+ square-sz (* i square-sz)) 2 "left" "top" img))}
    (nat-fold
     place-hline
     (sub1 (tile-grid-nrows grid))
     (nat-fold
      place-vline
      (sub1 (tile-grid-ncols grid))
      (empty-scene wid ht (tile-grid-background grid))))))

;; point-in-grid : nat nat grid -> int
;; test to see if the point (x, y) is in the area covered by the grid.
;; If it is, then return the index of the grid square; otherwise return -1.
;;
(define (point-in-grid x y grid)
  (local
    {(define col (floor (/ (- x (posn-x (tile-grid-ulc grid))) square-sz)))
     (define row (floor (/ (- y (posn-y (tile-grid-ulc grid))) square-sz)))}
    (if (and (<= 0 col (- (tile-grid-ncols grid) 1))
             (<= 0 row (- (tile-grid-nrows grid) 1)))
        (+ (* (tile-grid-ncols grid) row) col)
        -1)))

(check-expect (point-in-grid 350 50 board-grid) 1)
(check-expect (point-in-grid 390 150 board-grid) 4)
(check-expect (point-in-grid 250 150 board-grid) 3)
(check-expect (point-in-grid 150 150 board-grid) -1)

;; render-piece-with-border : num piece -> image
;; render piece as a circle with black border of given width
(define (render-piece-with-border w p)
  (local
    {(define p-color (if (symbol=? (piece-player p) 'orange) "orange" "blue"))
     (define radius (list-ref piece-radii (sub1 (piece-size p))))}
    (overlay (circle (- radius w) "solid" p-color)
             (circle radius "solid" "black"))))

;; render-piece : piece -> image
;; render piece as a plain circle
(define (render-piece p)
  (circle
   (list-ref piece-radii (sub1 (piece-size p)))
   "solid"
   (if (symbol=? (piece-player p) 'orange) "orange" "blue")))

;; draw-pieces : tile-grid boolean board -> image
;; draw board, in xray mode or not
(define (draw-pieces grid xray? squares)
  (local
    {(define ncols (tile-grid-ncols grid))
     (define render  ;; pick a render function for pieces based on the xray mode
       (if xray?
           (λ (ps) (foldl
                    (λ (p img) (overlay (render-piece-with-border 2 p) img))
                    empty-image ps))
           (λ (ps) (render-piece (first ps)))))
     ;; draw : board num num image -> image
     (define (draw pss col row img)
       (match pss
         ['() img]
         [(cons '() rest) (next rest col row img)]
         [(cons ps rest)
          (next rest col row
                (place-image (render ps)
                             (+ (* col square-sz) square-radius)
                             (+ (* row square-sz) square-radius)
                             img))]))
     ;; next : board num num image -> image
     (define (next pss col row img)
       (if (< (add1 col) ncols) (draw pss (add1 col) row img)
           (draw pss 0 (add1 row) img)))}
    (draw squares 0 0 (draw-grid-background grid))))

;; layout-window : image image image -> image
;;
(define (layout-window o-grid brd b-grid msg)
  (local {(define msg-img (text msg 24 "black"))}
   (above/align "left"
                (beside o-grid brd b-grid)
                (overlay
                 msg-img
                 (rectangle (+ (image-width msg-img) 10)
                            (+ (image-height msg-img) 10)
                            "solid" "white")))))

;;;;;;;;;;;;;;;;;;;; WORLD STATE CODE FOR PROJECT 2 ;;;;;;;;;;;;;;;;;;;;

;; a drag-piece is a (make-drag-piece p x y mk-move), where
;;  - p is a piece
;;  - x and y are integer coordinates
;;  - mk-move : square -> move is a function that will make the move object
;;    represented by completion of this drag-piece operation
(define-struct drag (piece x y mk-move))

;; a world-state is either a drag-piece or one of the following symbols:
;;   'waiting-for-human
;;   'waiting-for-computer
;;   'computer-thinking
;;   'victory
;;   'quit

;; a world is a (make-world g xray? inv log st checkpt), where
;;  - g is a game
;;  - xray? is a boolean, which is true when xray mode is on
;;  - inv is a pair (make-pair oinv binv), where
;;    - oinv is a 3x2 board for the orange inventory
;;    - binv is a 3x2 board for the blue inventory
;;  - log is a list of played moves in most-recent-first order
;;  - st is a world-state
;;  - checkpt is a world or false; it is a world (to restore) 
;;      when st is a drag-piece (see above), false otherwise
(define-struct world (game xray? inv log state checkpt))

;; world-update-state : world world-state -> world
;; functional update of a world's state component
(define (world-update-state wrld new-state)
  (match wrld
    [(world g xray? inv log _ cp) 
     (make-world g xray? inv log new-state cp)]))

;; world-update-game : world game -> world
;; functional update of a world's game component
(define (world-update-game wrld new-g)
  (match wrld
    [(world _ xray? inv log st cp) 
     (make-world new-g xray? inv log st cp)]))

;; new-world : player -> world
;; create an initial world where player p is the first player
(define (new-world p)
  (local
    {(define g (new-game p))}
    (make-world g
                false
                (make-pair
                 (map list (pair-fst (game-inv g)))
                 (map list (pair-snd (game-inv g))))
                '()
                'waiting-for-human
                #f)))

;; world-check-victory : player world -> world
;; check to see if the player has a victory in the current world;
;; if so, update the game state to 'victory 
(define (world-check-victory player wrld)
  (if (victory? player (world-game wrld))
      (world-update-state wrld 'victory)
      wrld))

;; world-victory? : world -> boolean
;; return true if the world is in a victory state
(define (world-victory? wrld)
  (and (symbol? (world-state wrld)) (symbol=? 'victory (world-state wrld))))

;; finish-move : world -> world
;; check to see if the current player wins; if not, switch players
(define (finish-move wrld)
  (if (world-victory? wrld)
      wrld
      (world-update-game wrld (switch-players (world-game wrld)))))

;; world-msg : world -> string
;; return a message that represents the current world state
(define (world-msg wrld)
  (match (world-state wrld)
    ['waiting-for-human
      (if (symbol=? (game-next (world-game wrld)) 'blue)
       "It is your turn; please play a blue piece."
       "It is your turn; please play an orange piece.")]
    [(drag _ _ _ _) "Place your piece on the board."]
    ['waiting-for-computer "I'm thinking ..."]
    ['victory (if (victory? 'blue (world-game wrld))
                  "Blue wins! Play again? (y/n)"
                  "Orange wins! Play again? (y/n)")]
    ['quit "Thanks for playing!"]
    [s (error 'world-msg 
              (string-append "unknown state: '" (symbol->string s)))]))

;; lift-piece? : player integer integer tile-grid board -> (or square -1)
;; calculate which piece the player has clicked on (if any)
(define (lift-piece? player x y grid brd)
  (local
    {(define sq (point-in-grid x y grid))
     (define ps (if (< sq 0) '() (pieces-at brd sq)))}
    (if (and (cons? ps) (symbol=? player (piece-player (first ps))))
        sq
        -1)))

(check-expect
 (lift-piece? 'blue 250 150 board-grid (build-list 9 (λ (i) (list blue1))))
 3)

;; remove-from-inv-board : piece -> board -> board
;; remove the piece from the board that represents an inventory
(define (remove-from-inv-board p)
  (local
    {(define (remove pss)
       (cond
         [(empty? pss) (error 'remove-from-inv-board "piece not found")]
         [(empty? (first pss)) (cons '() (remove (rest pss)))]
         [(piece=? (caar pss) p) (cons '() (rest pss))]
         [else (cons (first pss) (remove (rest pss)))]))}
    remove))
    
(check-expect ((remove-from-inv-board blue1) 
               (list (list blue2) '() (list orange1) '() '() (list blue1)))
              (list (list blue2) '() (list orange1) '() '() '()))

(check-expect ((remove-from-inv-board blue2) 
               (list (list blue2) '() (list orange1) '() '() (list blue1)))
              (list '() '() (list orange1) '() '() (list blue1)))

(check-expect ((remove-from-inv-board orange1)
               (list (list blue2) '() (list orange1) '() '() (list blue1)))
              (list (list blue2) '() '() '() '() (list blue1)))

;;;;;;;;;;;;;;;;;;;; VALIDATION CODE FOR PROJECT 2 ;;;;;;;;;;;;;;;;;;;;

;; all-pieces? : (listof piece) -> bool
;; Test that all of the game pieces (and no more) are in the given list.
(define (all-pieces? ps)
  (local
    {(define (count-piece p ps)
       (foldl (λ (q n) (if (piece=? p q) (add1 n) n)) 0 ps))}
    (and (= (count-piece orange1 ps) 2)
         (= (count-piece orange2 ps) 2)
         (= (count-piece orange3 ps) 2)
         (= (count-piece blue1 ps) 2)
         (= (count-piece blue2 ps) 2)
         (= (count-piece blue3 ps) 2))))

;; decreasing-size? : (listof piece) -> bool
;; test pieces in the list are in decreasing order of size
(define (decreasing-size? ps)
  (local
    {(define (chk prev-sz ps)
       (or (empty? ps)
           (and (> prev-sz (piece-size (first ps)))
                (chk (piece-size (first ps)) (rest ps)))))}
    (chk 4 ps)))

(check-expect (decreasing-size? (list blue3 blue2 blue2)) #f)
(check-expect (decreasing-size? (list blue3 blue2)) #t)
(check-expect (decreasing-size? '()) #t)
(check-expect (decreasing-size? (list blue1)) #t)

;; squares-valid? : board -> bool
;; are all the squares on a board valid?
;;
(define (squares-valid? pss) 
  (andmap decreasing-size? pss))

;; world-valid? : world -> bool
;; check to see if a world is in a valid state.  Returns false if not.
(define (world-valid? wrld)
  (match wrld
    [(world _ _ _ _ 'victory _) true]
    [(world _ _ _ _ 'quit _) true]
    [(world (game _ (pair goinv gbinv) brd) _ (pair oinv binv) _ st _)
     (local
       {(define brd-ps (list-flatten brd))
        (define drag-ps (if (drag? st) (list (drag-piece st)) '()))}
       (and (squares-valid? brd)
            (all-pieces? (append drag-ps brd-ps goinv gbinv))
            (all-pieces? (append drag-ps 
                                 brd-ps 
                                 (list-flatten oinv) 
                                 (list-flatten binv)))))]))         

(check-expect (world-valid? (new-world 'blue)) #t)

;;;;;;;;;;;;;;;;;;;; GUI CODE FOR PROJECT 2 ;;;;;;;;;;;;;;;;;;;;

;; draw-world : world -> image
;;
(define (draw-world wrld)
  (match wrld
    [(world (game _ _ brd) xray? (pair oinv binv) _ state _)
     (local
       {(define win (layout-window
                     (draw-pieces orange-inv-grid false oinv)
                     (draw-pieces board-grid xray? brd)
                     (draw-pieces blue-inv-grid false binv)
                     (world-msg wrld)))}
       (if (drag? state)
           (place-image (render-piece (drag-piece state)) 
                        (drag-x state) 
                        (drag-y state) 
                        win)
           win))]))

;; mouse-fn : world integer integer MouseEvent -> world
;;
(define (mouse-fn wrld x y evt)
  (match* (wrld evt)
    [((world _ _ inv _ (drag p _ _ mk-mv) _) "drag")
     (world-update-state wrld (make-drag p x y mk-mv))]
    ;; we can't handle moves drags outside the window, so revert to the checkpoint
    [((world _ _ _ _ (drag _ _ _ _) chkpt) "leave") chkpt]
    [((world g xray? inv log 'waiting-for-human _) "button-down")
     (local
       {(define player (game-next g))
        (define inv-sq 
          (lift-piece? player x y
                      (select-by-player player (make-pair orange-inv-grid 
                                                          blue-inv-grid))
                      (select-by-player player inv)))} 
       (if (<= 0 inv-sq)
           ;; an intro move; we remove the piece from both copies 
           ;; of the inventory and switch to the 'drag state.
           (local
             {(define p 
                (first (pieces-at (select-by-player player inv) inv-sq)))
              (define new-inv 
                (map-by-player (λ (pinv) (lift-top-piece pinv inv-sq))
                               player 
                               inv))}
             (make-world (apply-intro-lift p g) 
                         xray? 
                         new-inv 
                         log
                         (make-drag p x y (λ (sq) (make-intro p sq)))
                         wrld))
           ;; check for a shift
           (local
             {(define brd-sq (lift-piece? player x y board-grid (game-board g)))}
             (if (<= 0 brd-sq)
                 ;; a shift move
                 (local
                   {(define p (first (pieces-at (game-board g) brd-sq)))}
                   (world-check-victory
                    (other-player player)
                    (make-world
                    (pair-snd (apply-shft-lift brd-sq g))
                     xray?
                     inv
                     log
                     (make-drag p x y (λ (dst) (make-shft brd-sq dst)))
                     wrld)))
                 ;; no valid square was selected, so no state change
                 wrld))))]
    [((world g xray? inv log (drag p x y mk-move) chkpt) "button-up")
     (local
       {(define place-sq (point-in-grid x y board-grid))}
       (if (and (<= 0 place-sq) (square-available? p place-sq (game-board g)))
           ;; place the piece, check for victory, and then switch players
           (local
             {(define new-wrld
                (world-check-victory
                 (piece-player p)
                 (make-world
                  (apply-drop p place-sq g) xray? inv
                  (cons (mk-move place-sq) log)
                  'waiting-for-computer #f)))}
             (finish-move new-wrld))
           ;; illegal placement, so revert to the checkpoint
           chkpt))]
    [(_ _) wrld]))

;; tick-fn : (game -> move) ->  (world -> world)
;; given a move-choosing function for the computer to choose its moves, 
;;   tick-fn returns a (world->world) function that checks on every tick interval
;;   whether it's the computer's turn; if so, it uses the move-choosing function
;;   to choose and play a move, and if not, it returns the world as is
(define (tick-fn pick-move)
  (λ (wrld)
    (match wrld
      [(world g xray? inv log 'waiting-for-computer _)
       (match (pick-move g)
         [(intro p sq)
          ;; intro move: we place the piece, check for vicory, and then switch players
          (finish-move
           (world-check-victory
            (piece-player p)
            (make-world
             (apply-drop p sq (apply-intro-lift p g))
             xray?
             (map-by-player (remove-from-inv-board p) (piece-player p) inv)
             (cons (make-intro p sq) log)
             'waiting-for-human
             #f)))]
         [(shft src dst) 
          (match (apply-shft-lift src g)
            [(pair p tmp-g)
             (local
               {(define other (other-player (piece-player p)))
                (define tmp-wrld
                  (world-check-victory
                   other
                   (make-world tmp-g xray? inv log 'waiting-for-computer #f)))}
               (if (world-victory? tmp-wrld)
                tmp-wrld ;; human wins!
                ;; complete the shift
                (finish-move
                 (world-check-victory
                  (piece-player p)
                  (make-world
                   (apply-drop p dst tmp-g) xray? inv
                   (cons (make-shft src dst) log)
                   'waiting-for-human #f)))))])])]
      [_ wrld])))



                               
;;;;;;;;;;;;;;;;;;;; PROJECT 2 CODE ;;;;;;;;;;;;;;;;;;;;

;; world-toggle-xray : world -> world
;; negate the current xray? value
(define (world-toggle-xray w)
  (match w
    [(world g x i l s c)
     (make-world g (not x) i l s c)]))

;; safe-symbol=? : ANY symbol -> bool
;; convenience: check if something's a symbol, then compare it
(define (safe-symbol=? x s)
  (and (symbol? x) (symbol=? x s)))

;; stop? : world -> boolean
;; check to see if world is in the 'quit state
(define (stop? w)
  (safe-symbol=? (world-state w) 'quit))

;; available-intros : game -> (listof move)
;; compute the list of available intro moves for a given game
;;
(define (available-intros g)
    (match g
    [(game player inv brd)
     (local
       {(define pinv (select-by-player player inv))
        (define (fold-squares p)
          (λ (sq mvs) 
            (if (square-available? p sq brd) (cons (make-intro p sq) mvs) mvs)))
        (define (fold-pieces sz mvs)
          (local
            {(define p (make-piece (add1 sz) player))}
            (if (member? p pinv) (nat-fold (fold-squares p) 9 mvs) mvs)))}
       (nat-fold fold-pieces 3 '()))]))

;; available-shfts : game -> (listof move)
;; compute the list of available shft moves for a given game
;;
(define (available-shfts g)
  (match g
    [(game player inv brd)
     (local
       {(define (fold-squares src p)
          (λ (sq mvs)
            (if (and (not (equal? sq src)) (square-available? p sq brd))
                (cons (make-shft src sq) mvs)
                mvs)))
        (define (fold-board i pss mvs)
                            (match pss
                              ['() mvs]
                              [(cons '() r) (fold-board (add1 i) r mvs)]
                              [(cons (cons (piece sz player2) _) r)
                               (if (symbol=? player player2)
                                   (fold-board
                                    (add1 i)
                                    r
                                    (nat-fold (fold-squares i (make-piece sz player)) 9 mvs))
                                   (fold-board (add1 i) r mvs))]))}
       (fold-board 0 brd '()))]))

;; possible-moves : game -> (listof move)
;; enumerate possible moves from current game state
(define (possible-moves g)
  (append (available-intros g) (available-shfts g)))

;; random-move : game -> (or move false)
;; pick a legal move at random, if one exists
;;
(define (random-move game)
  (local
    {(define mvs (possible-moves game))}
    (if (not (empty? mvs))
        (list-ref mvs (random (length mvs)))
        false)))

;; key-fn : player -> world key-event -> world
;; respond to user's keystrokes
(define (key-fn first-player)
  (λ (wrld a-key)
    (local {(define state (world-state wrld))}
      (cond
        [(drag? state) wrld]  ;; ignore keys while dragging
        [else
         (match a-key
           ["q" (world-update-state wrld 'quit)]
           ["r" (new-world first-player)]
           ["x" (world-toggle-xray wrld)]
           ["y" (if (symbol=? state 'victory)
                    (new-world first-player)
                    wrld)]
           ["n" (if (symbol=? state 'victory)
                    (world-update-state wrld 'quit)
                    wrld)]
           [_ wrld])]))))
  
;; run-game : player (game -> move) -> world
;; given a first player and a move-choosing function,
;;   call big-bang and run the application
(define (run-game first-player pick-move)
  (big-bang (new-world first-player)
            [name "DrGobblers"]
            [check-with world-valid?]
            [on-tick (tick-fn pick-move) 0.75]
            [to-draw draw-world]
            [on-mouse mouse-fn]
            [on-key (key-fn first-player)]
            [stop-when stop? draw-world]))

;; run : player -> (listof string)
;; convenience: return log of most recently played game as list of strings
(define (run p)
  (map move->string (reverse (world-log (run-game p random-move)))))

;;;;;;;;;;;;;;;;;;;; PROJECT 3 CODE ;;;;;;;;;;;;;;;;;;;;

;;---------------------------------------------------
;;-----------------------Lab7------------------------
;;---------------------------------------------------

;; a board-set is a (listof board)
;; where each board in the same list is
;; in the same equivalence class. Equivalence
;; class refers to a set of at most eight boards
;; where the at most four of the 
;; boards are 90 degree ratations of one another
;; or where the boards are 90 degree rotations of the vertical
;; flip of the original board.
;; board-set does not contain duplicate values. 

;; board-set-insert: board board-set -> board-set
;; inserts a board into the board-set
(define (board-set-insert b bs)
  (cons b bs))


;; board-set-member? : board board-set -> bool
;; checkes if a board is in a board-set
(define (board-set-member? b bs)
  (member b bs))


;; board-invert : board -> board
;; inverts all colors of pieces in a board
(define (board-invert b)
  (local { (define (invert-p p) (if (equal? (piece-player p) 'blue)
                                    (make-piece (piece-size p) 'orange)
                                    (make-piece (piece-size p) 'blue)))
           (define (invert-lop lop) (map invert-p lop))
           (define (invert-board b) (map invert-lop b)) }
    (invert-board b)))


;; board-equiv-class : board -> board-set
;; builds the equivalent class for a board position
;; eyeball tested with the board configurations on the website
(define (board-equiv-class b)
  (local { (define fliped-b (map (λ (n) (list-ref b n)) '(2 1 0 5 4 3 8 7 6)))
           ;; loop4: board -> (listof boards)
           ;; rotates a board 90 degree and returns a list of the results
           (define (loop4 b)
            (local { (define (l counter lob)
                       (if (< counter 4)
                                (l (add1 counter) 
                                    (board-set-insert (map (λ (n) (if (empty? lob)
                                                          (list-ref b n)
                                                          (list-ref (car lob) n))) '(2 5 8 1 4 7 0 3 6)) lob))
                                lob)) }
             (l 0 '() )))
           ;; rm-same-board: (listof board) (listof board) -> (listof board)
           ;; removes duplicate boards from the board-set
           (define (rm-same-board r-lob n-lob)
             (cond
               [(empty? r-lob) n-lob]
               [else (local { (define (rm b lob)
                                (if (empty? lob)
                                    b
                                    (if (equal? b (car lob))
                                        '()
                                        (rm b (cdr lob))))) }
                       
                       (rm-same-board (cdr r-lob) (local { (define unique-board (rm (car r-lob) (cdr r-lob))) }
                                                    (if (empty? unique-board)
                                                        n-lob
                                                        (cons unique-board n-lob)))))]))}
                                    
                
                
                
           (reverse (rm-same-board (append  (loop4 b) (loop4 fliped-b)) '() ))))




;; board-equiv? : board board -> bool
;; returns whether or not two boards are in the same equivalence class
(define (board-equiv? b1 b2)
  (local { (define equiv-class (board-equiv-class b1)) }
    (board-set-member? b2 equiv-class)))

(define counter 0)
(define test-game (make-game 'orange
                             (make-pair (list orange1 orange2 orange3)
                                        (list blue1 blue2 blue3 blue3))
                             (list
                              (list orange3)
                              empty
                              (list orange2)
                              (list orange1)
                              (list blue2)
                              empty
                              empty
                              (list blue1)
                              empty)))

(define won-game (make-game 'blue
                             (make-pair (list orange1 orange2 orange3)
                                        (list blue1 blue2 blue3))
                             (list
                              (list orange3)
                              (list blue3)
                              (list orange2)
                              (list orange1)
                              (list blue2)
                              empty
                              empty
                              (list blue1)
                              empty)))
                            

(define test-game2 (new-game 'orange))

(define bugged-game (make-game 'orange
                               (make-pair (list orange2 orange2 orange3)
                                          (list blue3 blue3))
                               (list
                                (list orange3 orange1)
                                (list orange1)
                                empty
                                empty
                                (list blue2 blue1)
                                empty
                                empty
                                empty
                                (list blue2 blue1))))

;;-------------------------------------------------------------
;;-------------------------Tests-------------------------------
;;-------------------------------------------------------------


;; test pieces
(define o1 (make-piece 1 'orange))
(define o2 (make-piece 2 'orange))
(define o3 (make-piece 3 'orange))
(define b1 (make-piece 1 'blue))
(define b2 (make-piece 2 'blue))
(define b3 (make-piece 3 'blue))


(check-expect (board-equiv? (list
                             (list b3)
                             (list o1)
                             empty empty empty
                             empty empty empty
                             empty)
                            (list
                             empty empty empty
                             empty empty empty 
                             empty (list o1) (list b3)))
              true)

(check-expect (board-equiv? (list
                             (list b3)
                             (list o1)
                             empty empty empty
                             empty empty empty
                             empty)
                            (list
                             (list b3) empty empty
                             (list o1) empty empty
                             empty empty empty))
              #t)

(check-expect (board-equiv? (list
                             (list b1) empty empty
                             empty empty empty
                             empty empty empty)
                            (list
                             (list b1) empty empty 
                             empty empty empty
                             empty empty empty))
              #t)

(check-expect (board-equiv? site-last-board
                            (list
                             empty
                             (list b3)
                             (list o1)
                             (list o2 o1)
                             (list b1)
                             (list b2)
                             (list o3 o2 b1)
                             (list o3 b2)
                             (list b3)))
              #t)

(check-expect (length (board-equiv-class (list 
                                          (list o1) empty empty
                                          empty empty empty
                                          empty empty empty)))
              4)
  
(check-expect (length (board-equiv-class (list 
                                          empty empty empty
                                          empty (list o3 o2 o1) empty
                                          empty empty empty)))
              1)                                        
                             

(define site-last-board (list
                         (list o3 o2 b1)
                         (list o3 b2)
                         (list b3)
                         (list o2 o1)
                         (list b1)
                         (list b2)
                         empty
                         (list b3)
                         (list o1)))

;"These are the boards at the end of lab7 from the site"

;(map (λ(g)(game-image true g)) 
 ;    (map (λ (b) (make-game 'blue '() '() b)) 
  ;        (board-equiv-class site-last-board)))

;"This is the board-set of a board with only pieces in the center"
;(map (λ(g)(game-image true g)) 
 ;    (map (λ (b) (make-game 'blue '() '() b)) 
  ;        (board-equiv-class (list empty empty empty
   ;                                empty (list o3 o2 o1) empty
    ;                               empty empty empty))))
;"This is the board-set of a board with only pieces in one corner"
;(map (λ(g)(game-image true g)) 
 ;    (map (λ (b) (make-game 'blue '() '() b)) 
  ;        (board-equiv-class (list (list b3 o2 b1) empty empty
   ;                                empty  empty empty
    ;                               empty empty empty))))
;"This is the board-set of a board with only pieces in two opposing corners"
;(map (λ(g)(game-image true g)) 
 ;    (map (λ (b) (make-game 'blue '() '() b)) 
  ;        (board-equiv-class (list (list o3 b2 o1) empty empty
   ;                                empty empty empty
     ;                              empty empty (list b3 o2 b1)))))


                                 
;; === minimax
;; apply-move : game move -> game
;; applies a move to a game
;; DOES NOT CHECK WHETHER MOVE IS VALID
(define (apply-move g m)
  (match m
    [(intro p sq) (local { (define new-game  (apply-drop p sq (apply-intro-lift p g))) }
                    (make-game (if (equal? (game-next g) 'blue) 'orange 'blue)
                               (game-inv new-game)
                               (game-board new-game)))]
    [(shft src dst) (local { (define new-game (match (apply-shft-lift src g)
                                                 [(pair p tmp-g)
                                                  (if (victory? (if (equal? (game-next g) 'blue) 'orange 'blue) tmp-g)
                                                      (make-game (if (equal? (game-next g) 'blue) 'orange 'blue) 
                                                                 (game-next tmp-g) (game-board tmp-g))
                                                      (apply-drop p dst tmp-g))])) }
                      (make-game (if (equal? (game-next g) 'blue) 'orange 'blue) (game-inv new-game) (game-board new-game)))]))


;; score : game -> integer
;; assign numeric score to game
(define (score g)
  (cond
    [(victory? 'orange g) 1]
    [(victory? 'blue g) -1]
    [else 0]))

;; minimax : nat game -> integer
;; given max ply and game, return score
(define (minimax ply g)
  (local {(define player (game-next g)) 
          (define (traverse i g)
             (cond
               [(or (or (victory? 'blue g) (victory? 'orange g) ) (>= i ply)) (score g)]
               [(symbol=? player 'blue) (apply min (map (λ (new-game) (traverse (add1 i) new-game)) 
                                                        (map (λ (m) (apply-move g m)) (possible-moves g))))]
               [else (apply max (map (λ (new-game) (traverse (add1 i) new-game)) 
                                     (map (λ (m) (apply-move g m)) (possible-moves g))))]))}
    (traverse 0 g)))

;; minimax-choose-move : nat game -> move
;; given max ply and game, choose best available move
(define (minimax-choose-move ply g)
  (choose-move-aux ply g false))
  
;; choose-move-aux : nat game bool -> move
;; given max ply and game, return best move, uses transposition table
;; if bool is true; does not use if bool is false.
(define (choose-move-aux ply g tt?)
  (local { (define next-moves (possible-moves g))
           (define next-games (map (λ (m) (apply-move g m)) next-moves))
           (define proc (if tt? minimax-tt minimax))
           (define los (map (λ (g) (proc (sub1 ply) g)) next-games)) 
           (define score (apply (if (equal? (game-next g) 'orange) max min) los))
           (define (find-indexes item counter lst loi)
             (if (empty? lst) loi
                 (if (equal? item (car lst))
                     (find-indexes item (add1 counter) (cdr lst) (cons counter loi))
                     (find-indexes item (add1 counter) (cdr lst) loi))))
          (define (random-item lst)
            (list-ref lst (random (length lst))))}
    (begin (display los) (display (map move->string next-moves))
           (if tt? (TT-insert! (h-v g) score ply) void)
      (if (either-victory? g) 
          (error "game already won") 
           (list-ref next-moves 
                     (car (find-indexes score 0 los '())) )))))


;; AI-move : nat -> (game -> move)
;; wraps minimax into a form acceptable to run-game
(define (AI-move ply)
  (λ (g) (minimax-choose-move ply g)))
    

;; === minimax with transposition table

;; a tt-entry is a (make-tt-entry hash score depth)
;; where hash, score, and depth are numbers
(define-struct tt-entry (hash score depth))

(define TT-size 325051) ;; a prime number
(define TT (make-vector TT-size empty))

;; h-v: game -> nat
;; finds the hash value for a game
(define (h-v g)
  (match g
    [(game next pair board)
     (+ (if (equal? next 'orange) 0 1)
      (foldl + 0  
            (map (λ (c 2n) (* c 2n)) 
          (map (λ (pieces) (s->val pieces)) board)
          (map (λ (n) (expt 2 n)) '(49 43 37 31 25 19 13 7 1)))))]))

;; s->val : (listof pieces) -> nat
;; computes the bitstring then value for a square
(define (s->val pieces)
  (local { (define (lp i pieces* str)
             (if (<= i 0)
                 str
                 (if (empty? pieces*) 
                     (lp (sub1 i) pieces* (string-append str "00"))
                 (match (car pieces*)
                   [(piece s p) 
                        (lp (sub1 i) (if (= s i) (cdr pieces*) pieces*) 
                            (string-append 
                                    str
                                    (if (= s i) 
                                        (if (equal? p 'orange) "10" "01")
                                        "00")))])))) }
    
    
 (if (empty? pieces) 0 (string->number (lp 3 pieces "") 2))) )
 
;; find: (listof tt-entry) hash -> (or tt-entry false)
;; finds a tt entry in a given list given hash
(define (find lot h)
  (match lot
    ['() #f]
    [(cons x xs) (if (= (tt-entry-hash x) h)
                     x
                     (find xs h))]))

;; find-ply: (listof tt-entry) nat -> (or tt-entry false)
;; finds a tt entry in a given list given ply
(define (find-ply lot n)
  (match lot
    ['() #f]
    [(cons x xs) (if (= (tt-entry-depth x) n)
                     x
                     (find xs n))]))


;; TT-find: (listof hash) -> (or tt-entry false)
;; given a hash, finds a tt-entry within TT
(define (TT-find loh)
  (if (empty? loh) 
      #f
      (match (modulo (car loh) TT-size)
        [i 
         (match (find (vector-ref TT i) (car loh))
         [#f (TT-find (cdr loh))]
         [entry entry]) ])))

;; TT-search-ply: nat -> (listof tt-entry)
(define (TT-search-ply s)
  (nat-fold (λ (i acc) (match (find-ply (vector-ref TT i) s)
                       [result (if (false? result)
                                   acc
                                   (cons result acc))]))  TT-size '()))

;; TT-insert!: hash score num -> void
;; makes and inserts a TT entry into the TT
(define (TT-insert! h s ply)
  (match (modulo h TT-size)
    [i (vector-set! TT i (cons (make-tt-entry h s ply)
                               (vector-ref TT i)))]))

;; either-victory? : game -> bool
;; given a game, returns a bool indicating
;; whether either player has won the game
(define (either-victory? g)
  (or (victory? 'blue g) (victory? 'orange g)))

;; TT-display : void -> void
;; diplays all the extant entries
(define (TT-display)
  (nat-fold (λ (i acc) (if (empty? (vector-ref TT i))
                          void
                          (display (vector-ref TT i)))) TT-size void))

;; h-equiv: g bool-> (listof hash)
;; given a game, returns a list of the hash
;; of the boards in the equivalence class if bool is false
;; returns a list of the hash of the boards in 
;; the inverted boards's equivalence if bool is true
(define (h-equiv g inverted)
  (match g
    [(game next inv board)
     (local { (define g* (if inverted (make-game next inv (board-invert board)) g))
              (define equiv-boards (board-equiv-class (game-board g*)))
              (define equiv-games (map (λ (b) (make-game next inv b)) equiv-boards)) }
(map h-v equiv-games))])) 


;; minimax-tt : nat game -> integer
;; given max ply and game, return score using minimax search with the transposition table
(define (minimax-tt ply g)
(traverse (game-next g) ply g))


;; traverse: player i g -> score
;; traverses the game tree to find the score
;; of a given state
(define (traverse player i g)
             (cond
               [(or (either-victory? g) (<= i 0)) (score g)]
               [else (TT-match player i g)]))


;; TT-match: player nat g -> integer
;; given game, returns the scores from the transposition table
;; if it exists and is valid, or computes the new score if it doens't 
;; or is invalid and adds it to the transposition table
(define (TT-match player i g)
  (local { (define (find-inverted g)
             (match (TT-find (h-equiv g true))
                         [(tt-entry h s ply)
                          (if (tt-entry-valid ply i s)
                              (- s)
                        (traverse-insert player i g))]
                         [#f (traverse-insert player i g)])) }
    
  (match (TT-find (h-equiv g false))
                  [(tt-entry h s ply) 
                   (if (tt-entry-valid ply i s)
                       s
                       (find-inverted g))]
                  [#f (find-inverted g)])))

;; traverse-insert: player i g -> score
;; traverses the game tree and builds score values
;; while inserting it into the transposition table
(define (traverse-insert player i g)
               (local { (define score 
                                 (apply (if (equal? player 'blue) min max) 
                                        (map (λ (new-game) (traverse player (sub1 i) new-game)) 
                                             (map (λ (m) (apply-move g m)) (possible-moves g))))) }
                        (begin (TT-insert! (h-v g) score i)
                               score)))

;; tt-entry-valid: ply i s -> bool
;; given the current ply i, the ply of the entry
;; and the score of the entry, returns true if the 
;; entry can be used as a result, returns false if it can't. 
(define (tt-entry-valid p i s)
  (or (>= p i) 
      (or (= 1 s)
          (= -1 s))))
                               
;; minimax-tt-choose-move : nat game -> move
;; given max ply and game, return best move, and use transposition table
(define (minimax-tt-choose-move ply g)
  (choose-move-aux ply g true))



;; tt-move: nat -> (game -> move)
;; wraps minimax-tt-choose-move and implants ply
(define (tt-move n)
(λ (g) (minimax-tt-choose-move n g)))

;; === main functions

;; run-mm : nat player -> bool
;; runs game and returns true
(define (run-mm ply human-player)
  ((λ (x) true)
   (run-game human-player (AI-move ply))))

;; run-mm-tt : nat player -> bool
;; runs game and returns true
(define (run-mm-tt ply human-player)
  ((λ (x) true)
   (run-game human-player (tt-move ply))))
